**************************************************************************
		Important Websites
**************************************************************************
- https://github.com/trailheadapps/lwc-recipes
- https://developer.salesforce.com/docs/component-library/documentation/en/lwc/testing
- https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.unit_testing_using_jest_run_tests
-  jestjs.io/docs/en/troubleshooting.
- https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.use_navigate
- https://developer.salesforce.com/docs/component-library/bundle/lightning-card/example
- https://archive-1_0_5.lightningdesignsystem.com/components/grid-system



**************************************************************************

// DevHub org in order to create scratch orgs
Scratch orgs has expiry of max 30 days
1 devhub can have max 25 scratch orgs
Scratch orgs are code driven
enable devhub in setup

-------------Commands---------------------

****************************create project**************************************************
//sfdx force:project:create -n "LWC tutorials"
	force is the namespace, project is topic/category of commands and under that category there 		is a command called create.

*******authorize devhub to create a scratch org and use it ***********************************
//sfdx force:auth:web:login -a lwcSneha -d
	auth is topic
	-a is alias
	-d is to make it default

***********Create Scratch Orgs**********************************
// Make changes in the scratch org config file ->
	config->project-scratch-def.json -> add attribute-> "hasSampleData":true

//sfdx force:org:create -a lwcScratchOrg1 -d 30 -f .\config\project-scratch-def.json
	-a for alias
	-d for duration
	-f for location of config file

//Set the scratch org as the default org
	ctrl+shft+P => sfdx set a default org and choose the scratch org

************************Open Scratch Org**************************************
//sfdx force:org:open

**************************Common Commands**************************************
//sfdx commands
//sfdx force:org:create --help -> to get to know the parameters needed and more info on that 				particular command

----------------------Create Lightning Component------------------------------------------------
//sfdx force:lightning:component:create -n FirstLightningComponent -d force-app\main\default\lwc

----------------------Create Apex Class---------------------------------------------------------
//sfdx force:apex:class:create -n FirstApexViaVsCode -d .\force-app\main\default\classes

-------------------------Push to scratch org----------------------------------------------------
//sfdx force:source:push

**********************************************************************************************
					RUN LWC LOCALLY
**********************************************************************************************
URL - https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.get_started_local_dev_setup

in cmd -> sfdx plugins:install @salesforce/lwc-dev-server
//sfdx plugins:update
	for updates
//sfdx force:lightning:lwc:start
	start local server

************************************************************************************************
Open Salesforce Pages and LEX App Directly From VSCode
***************************************************************************************************
URL - https://medium.com/@idanblich/open-salesforce-pages-and-lex-app-directly-from-vscode-38e889e1759a

Steps:
1. Create tasks.json file in .vscode folder
2. ctrl+shift+P -> tasks:Run Build Task -> choose // the page or component should be selected in order to mention which task to run and should also be deployed to the org.

(or cmd)->	task: sfdx force:org:open --path /apex/ApiTest
**************************************************************************************************
MISCELLANEOUS
***************************************************************************************************
Run SOQL>>sfdx force:data:soql:query --query SELECT Id, Name FROM Account
Create VF page>> sfdx force:visualforce:page:create --pagename ApiTest --label ApiTest --outputdir force-app\main\default\pages
Retrieve via package.xml in project manifest>>sfdx force:source:retrieve --manifest c:\Users\sa\Projects\VfPageAndApi\manifest\package.xml


***********************************************************************************************************************
Building First Lightning web component
************************************************************************************************
//sfdx force:lightning:component:create -n FirstExample -d .\force-app\main\default\lwc --type lwc

In order to make the component available for the lightning app builder change the <isExposed> attribute in the .xml file of the component from false to true.

In order to make the component available for record page, home page and app page --> set the targets in the xml file(aka config file)

	<targets>
        <target>lightning__RecordPage</target>
        <target>lightning__AppPage</target>
        <target>lightning__HomePage</target>
    </targets>


***************************Data Binding***********************************************************
In HTML => {property}
	eg. <template>
    <lightning-card title="Hello">
        <div class="slds-a-around-medium">
        <p class="slds-p-horizontal_small">Hello {name}</p>
    </div>
    <div class="slds-a-around-medium">

        <lightning-input label="Enter Name" value={name} onchange={changeHandler}></lightning-input>
    </div>
    </lightning-card>
</template>

In JS => importing track to make the property reactive so that whenever the property value changes, it renders the component.

	eg. 
	import { LightningElement,track } from 'lwc';

export default class DataBinding2 extends LightningElement {
    @track name = "World";
    
    changeHandler(event){
        this.name = event.target.value;
    }
}


HTML to JS -> done by Handler
JS to HTML -> done by track


*************************************************************************************************
		Rendering DOM elements Conditionally
*************************************************************************************************
- Use if:true|false directive with nested template tag
	if:true|false = {property}

**************************************************************************************************
		Rendering a list using iterator directive
***************************************************************************************************
- Either by using for:each directive or the iterative directive inside of template tag
- Iterator directive has an advantage as u can have first and last properties in that.
- Always use a key directive to assign a unique Id to each item so that if a particular item changes then the framework will use the Id to re render only the particular item changed, therefore performance optimization done.

-----------------------------FOREACH-----------------------------------------------
for:each directive use for:item = "currentItem" to access the current item

 	<ul>
           <template for:each={contacts} for:item="contact">
           <li key={contact.id}>{contact.name},{contact.title}</li>
        </template>
       </ul>


-----------------------------ITERATIVE---------------------------------------------
iterator:iteratorName={array}

-Using iteratorName we can access the below mentioned properties
	value
	index
	first - boolean value
	last - Boolean value

 <ul>
           <template iterator:it={contacts}>
               <li key={it.value.id}>
                   <div if:true={it.first} class="iterator-first"></div>
                   {it.value.name},{it.value.title}
                   <div if:true={it.last} class="iterator-last"></div>
               </li>
           </template>
       </ul>



**************************************************************************************************
				Public Properties in LWC
**************************************************************************************************
- To make properties public and reactive so that they can be used by another component -> use api decorator (@api)
- In child component(basically tht declares the public properties) -> the public properties can have default values only.
- Parent component that uses the child component in the markup can set the values.
- In order to call child component from parent component(same for attribute values of that property) 	-> use kebab case notation
- Property in .js file is mapped to the attribute in the .html file -> so in js its camel case and in html it is kebab case
- Make config changes on the parent component bcz that is what is going to be pushed to lightning app.
- Take proper care while naming.

***************************************************************************************************
			Difference between private reactive and private non reactive properties
****************************************************************************************************
- Reactive Property re-renders the component ie the changed value is vivible on the screen whereas non- reactive property doesnt ie untill the component renders the value is non visible.

****************************************************************************************************
			Boolean Properties in LWC
****************************************************************************************************
- Are public and reactive and hence uses @api decorator.
- Default value always false
- If child component used in parent then value becomes true otherwise remains false
 
****************************************************************************************************
			Component Lifecycle Hooks
****************************************************************************************************
Step 1: Constructor of Parent component is called.
Step 2: Check if any public property to be updated??
	Step 2.1: then update the public property value
Step 3: Parent Component inserted into DOM
Step 4: Connected Callback() called on Parent
Step 5: Parent rendered.
Step 6: Constructor of Child component is called.
Step 7: Check if any public property to be updated??
	Step 7.1: then update the public property value
Step 8: Child Component inserted into DOM
Step 9: Connected Callback() called on Child
Step 10: Child rendered.
Step 11: Rendered callback() called on child.
Step 12: Rendered callback() called on Parent.

--------------------------------When Component instance is removed from the DOM---------------------
Step 1: Parent Component removed from DOM
Step 2: Disconnected callback() called on Parent
Step 3: Child Component removed from DOM
Step 4: Disconnected callback() called on Child. 

****************************************************************************************************
			Component Communication through events
****************************************************************************************************
3 ways:
1. Parent to child -> Communication using methods in LWC
2. Child to Parent -> Custom event Communication in LWC
3. Two completely unrelated components -> Publish and subscriber model

------------------------------Parent to child-------------------------------------------------------
- In Aura components, child component methods could be called by the parent component by using <aura:method>
Same is done in case of LWC -> instead of aura methods they are javascript methods
@api decorator used in child methods which needs to be exposed so that it can be consumed by the parent component using javascript API.

- In parent component -> this.template.querySelector('c-todo').methodName(event.target.value);

-----------------------------Child to Parent--------------------------------------------------------
- Use Custom events
- Child component will create and dispatch the event
- Parent component is responsible for handling the event
- Create an event -> (done inside child)
	Use customEvent() constructor and pass custom event name and details of the event.
	new customEvent(eventName, props);

- Dispatch an event -> (done inside child)
	EventTarget.dispatchEvent() method
	this.dispatchEvent(new customEvent(eventname, props)); //eventname should always be in 	lowercase

- Ways to handle an event:
	1. declaration via HTML -> add 'on' prefix in the eventName in the parent component during 		calling the child component.
		<c-todo oneventName={listenerHandler}>
	2. using JS method addEventListner() ->
		this.template.addEventListner('eventName', this.handleNotification.bind(this));
		when doing this add bubbles:true in props also for event initialization

 
----------------------------------Unrelated components-----------------------------
- Using Publish-Subscriber model.
- similar to application events in aura component.
- Has 2 different types of components:
	publisher: can have multiple subscribers i.e whenever a publisher fires an event, all the 	subscribers subscribed to tht publisher will recieve that event.

	subscriber: 

- Rules to be followed in this model:
	1. Need to use the singleton library which follows the publish-subscriber pattern ie there 		is a js file -> pubsub.js which needs to be added.
	2. Rules to be followed by Publisher:
		2.a. Publisher needs to fire the events -> needs to import the fireEvent from 				pubsub.js in the publisher component and also define the pageReference as the 				currentPageReference.
		- fireEvent(pageReference, eventName, eventdetail in the publisher component)	
			- import {currentPageReference} from 'lightning/navigation';
			- import {fireEvent} from 'c/pubsub';
			- fireEvent(this.pageRef, eventName, this.message)

	3. Rules to be followed by subscriber component:
		3.a. needs to import registerListener, unregisterAllListeners from the pubsub.js file 			in the subscriber component.
			- import {currentPageReference} from 'lightning/navigation';
			- import {registerListener, unregisterAllListeners} from 'c/pubsub';
			- connectedCallback(){
			
				registerListener('eventName', this.handlerName, this);			
			}
			
			- disconnectedCallback(){
				unregisterAllListeners(this);
				}


***************************************************************************************************
				Access data from Salesforce
****************************************************************************************************
- 3 options available:
	1. using Lightning Data Services
	2. using Lightning Data Service Base components
		- best way
		- bcz no need to write any apex controllers
	3. using @aura enabled
		- for complex issues which cant be solved by 2.

---------------------Create record using LDS--------------------------------
- import {createRecord} from "lightning/uiRecordApi"; // to create records
- mapping of fields:
	const fields={'LastName':this.contactName, 'Phone':this.phone, 	'Email':this.email};
- Adding object api name:
	const recordInput = {apiName:'Contact', fields};
-Pass recordInput to createRecord method we imported:
	createRecord(recordInput).then (response => {
console.log('created');
}).catch(error => {
console.log('error',error.body.message);
});


------------------Create and view using LDS---------------------------------
- import wire decorator also.
- import {createRecord, getRecord} from 'lightning/uiRecordApi';
- create fieldArray specifying the fields needed.
	const fieldArray = ['contact.lastName', 'contact.Phone', 		'contact.email'];
- use @wire to get the record through getRecord method.
	@wire(getRecord{recordId:$recordId, fields:fieldArray}) 	contactRecord;

----------------------------Using Base Components---------------------------
-3 types of base components:
	1. lightning-record-form- supports edit,view and read only models
	2. lightning-record-edit-form - displays editable form
	3.lightning-record-view-form-components - displays read-only form
- these compoenets provide layouts to perform create, update and view record without the need of writing apex code.

- <lightning-record-form record-id={recordId} object-api-name="Account" 	mode="view" layout-type="Compact"></lightning-record-form>
- import api decorator

-------------------Display Records with custom layout using base comp-------
<lightning-record-view-form record-id={recordId} object-api-name="Account">
        <div class="slds-grid">
            <div class = "slds-col slds-size--1-of-2">
                <lightning-output-field field-name="Name"></lightning-output-field>
                <lightning-output-field field-name="Phone"></lightning-output-field>
            </div>
            <div class = "slds-col slds-size--2-of-2">
                <lightning-output-field field-name="Industry"></lightning-output-field>
                <lightning-output-field field-name="Description"></lightning-output-field>
            </div>
        </div>
    </lightning-record-view-form>

---------------Create new record using base components----------------------
 <lightning-record-edit-form object-api-name="Contact">

---------------Create and view records using base component----------------
- use onsuccess attribute to get the id of the record.
-  <lightning-record-edit-form object-api-name="Contact" onsuccess=	{createContact}>

- @track recordId;

    createContact(event){
        this.recordId = event.detail.id;
    }
}

--------------------Fetch records via Apex----------------------------------
import getAllContacts from '@salesforce/apex/ContactManger.getContacts';
export default class FetchRecordsViaApex25 extends LightningElement {
    @wire (getAllContacts) contacts;

    get contactRecieved(){
        console.log("Contacts "+this.contacts);
        console.log("Contacts.data "+this.contacts.data);
        if(this.contacts){
            return true;
        }
        return false;
    }
}

- in apex class follow these rules:
	1. make methods public or global
	2. make methods @auraEnabled(cacheable=true)
	3. methods should be static

***************************************************************************
		Toast Notification in LWC
****************************************************************************
- import show toast event
	import { ShowToastEvent } from 'lightning/platformShowToastEvent';

- inside handler call showToast event and then dispatch it

	ErrorHandler(event){
        
            const showError = new ShowToastEvent(
                {
                    title:"Success",
                    message:"Success message",
                    variant:"Success"

                }
            );
            this.dispatchEvent(showError);
    }



****************************************************************************
		NAVIGATION SERVICE IN LWC
****************************************************************************
- Used to navigate to different pages.
- use 'lightning\navigation' service.
- the service is available only in
	lightning experience
	lightning communities
	lightning app
- Not supported in
	lightning components for VF
	lightning out
- the navigation service uses a pageReference. 
- PageReference is a JS object that has the following properties:
	- type (required)
	- attributes (required)
	- state 
- the type generates a unique url format which takes the attributes defined
- types of pageReferences supported by Salesforce are:
	Lightning component
	Knowledge Article
	Named Page
	Navigation Item Page
	Object Page
	Record Page
	record Relationship Page
	Web Page
- Steps to follow to use navigation service in LWC:
	1. import {NavigationMixin} from 'lightning/navigation';
	2. Apply NavigationMixin function to the component's base class
		export default class <className> extends 		NavigationMixin(LightningElement) {}
	3. Create a JS pageReference and define its type and attributes
		({
			type:'standard__recordPage',
			attributes:{
					recordId:this.recordId,
					objectApiName:"Account",
					actionName:"edit"
					}
		})
	4. Dispatch the service and pass the pageReference to it:
		this[NavigationMixin.Navigate](pageReference details 		mentioned in the previous step)

------------------Types of pages and attributes----------------------------
1. type:'standard__objectPage',
            attributes:{
                
                objectApiName:"Account",
                actionName: "new"
            }

2. type:'standard__recordPage',
            attributes:{
                recordId:this.recordId,
                objectApiName:"Account",
                actionName: "edit"
            }

3. type:'standard__recordPage',
            attributes:{
                recordId:this.recordId,
                objectApiName:"Account",
                actionName: "view"
            }

4. type:"standard__objectPage",
            attributes:{
                objectApiName: 'Contact',
                actionName: 'list'

            },
            state:{filterName:"Recent"}
        

5.  type:"standard__recordRelationshipPage",
            attributes:{
                recordId: this.recordId,
                objectApiName: 'Account',
                relationshipApiName:"Contacts",
                actionName: 'view'
            }

6. this[NavigationMixin.Navigate]({
            type:"standard__webPage",
            attributes:{
                url: 'http://google.co.in'
            }

7. type:"standard__objectPage",
            attributes:{
                objectApiName: 'Account',
                actionName: 'home'
            }

8. type:"standard__namedPage",
            attributes:{
               
                pageName: 'home'
            }

9. this[NavigationMixin.Navigate]({
            type:"standard__namedPage",
            attributes:{
                pageName: 'chatter'
            }


****************************************************************************
		UNIT TEST LWC using JEST
****************************************************************************
- Run Jest tests at the command line or (with some configuration) within your IDE. 
- Jest tests don’t run in a browser or connect to an org, so they run fast. - When run in “watch mode” they give you immediate feedback while you’re coding. 
- Jest tests work only with Lightning web components, they don’t work with Aura components.

- Write Jest tests to:

	Test a component in isolation
	Test a component’s public API (@api properties and methods, events)
	Test basic user interaction (clicks)
	Verify the DOM output of a component
	Verify that events fire when expected

- install nodejs
- install npm
	npm install
- npm install @salesforce/sfdx-lwc-jest --save-dev
- By default, an SFDX project includes these script entries in the scripts block of its package.json file. If your project’s file doesn’t include them, add them:
	
	{
  ...
  "scripts": {
    ...
    "test": "npm run test:unit",
    "test:unit": "sfdx-lwc-jest",
    "test:unit:watch": "sfdx-lwc-jest --watch",
    "test:unit:debug": "sfdx-lwc-jest --debug",
    "test:unit:coverage": "sfdx-lwc-jest --coverage",
    ...
  },
  ...
}


- To run all tests for your project, use the Salesforce CLI command sfdx force:lightning:lwc:test:run from the root folder of your project. Otherwise, run the command that you added to the scripts block of your project’s package.json file.
	- npm run test:unit

-----------Run Tests Continuously During Development-----------------------
- To run all tests for a single component every time you save changes, change directories to the component directory and run the sfdx-lwc-jest command with the --watch parameter. Use the entry that you added to the scripts block of your project’s package.json file.

	npm run test:unit:watch

-------------------Run Tests in Jest Debug mode---------------------------
- To run the project’s Jest tests in debug mode, run the sfdx-lwc-jest command with the --debug parameter. Use the entry that you added to the scripts block of your project’s package.json file.

	npm run test:unit:debug


-------------Write Jest Tests for Lightning Web Components------------------
- Write your component tests in local JavaScript files. Commit them to version control along with the component itself. Jest tests aren’t saved to Salesforce.

- Jest tests are written, saved, and run differently than Jasmine or Mocha tests written for the Lightning Testing Service. Jest tests are local only, and are saved and run independently of Salesforce.

- To create a test directory and a boilerplate test file within the directory.
	-  sfdx force:lightning:lwc:test:create

-The following command creates a test directory and file for testing the myButton Lightning web component.
	- sfdx force:lightning:lwc:test:create -f force-			app/main/default/lwc/myButton/myButton.js

- After you use the Salesforce CLI create command, you see a folder named __tests__ at the top level of your component’s bundle directory, such as force-app/main/default/lwc/myButton/__tests__. Otherwise, create the folder yourself. Save all tests for this component inside the __tests__ folder.


------------------------Update .forceignore--------------------------------
- To ensure that the __tests__ folder and its contents are never saved to Salesforce, add this glob pattern to the .forceignore file for each of your projects. The Salesforce CLI command sfdx force:lightning:lwc:test:setup does this task for you.

	- **/__tests__/**


-------------------------Write a Basic Test---------------------------------
- imports the createElement method, This method is available only in tests
	import { createElement } from 'lwc';

- import the component to test, ie c/hello
	import Hello from 'c/hello';

- A describe block defines a test suite. A test suite contains one or more tests that belong together from a functional point of view.
	describe('c-hello', () => {
   	 ...
	});

- The Jest afterEach() method resets the DOM at the end of the test.
- Since a browser isn’t running when tests run, Jest uses jsdom to provide an environment that behaves much like a browser’s DOM or document. Jest has a dependency on jsdom, which is a Node.js project, so jsdom is downloaded during installation of the sfdx-lwc-jest project the same way Jest itself is.
- Each test file shares a single instance of jsdom, and changes aren’t reset between tests inside the file. Therefore it’s a best practice to clean up between tests, so that a test’s output doesn’t affect any other test.

	afterEach(() => {
    // The jsdom instance is shared across test cases in a single file so reset the DOM
    while (document.body.firstChild) {
        document.body.removeChild(document.body.firstChild);
    }
});


------------------------it (or test) block----------------------------------
- 'it' is an alias for 'test'. Use whichever word allows you to describe the expected behavior accurately.

- An it block describes a single test. A test represents a single functional unit that you want to test.

	it('displays greeting', () => {
    	...
	});

- The test uses the imported createElement method to create an instance of the component to test, in this case, c-hello.
	const element = createElement('c-hello', {
    is: Hello
});

- The test then calls appendChild to add the component to the test’s version of document.
The appendChild() call inserts the component into the DOM and the lifecycle hooks connectedCallback() and renderedCallback() are called.
	
	document.body.appendChild(element);

- The next step is to use a standard DOM query method to search the DOM for the element. 
- Use element.shadowRoot as the parent for the query. 
- It's a test-only API that lets you peek across the shadow boundary to inspect a component’s shadow tree. It’s the test equivalent of this.template.

	const div = element.shadowRoot.querySelector('div');

- Finally, the expect statement is an assertion of the success condition: that the text of the element is “Hello, World!”
	
	const div = element.shadowRoot.querySelector('div');
	expect(div.textContent).toBe('Hello, World!');

// hello.test.js
import { createElement } from 'lwc';
import Hello from 'c/hello';

describe('c-hello', () => {
    afterEach(() => {
        // The jsdom instance is shared across test cases in a single file so reset the DOM
        while (document.body.firstChild) {
            document.body.removeChild(document.body.firstChild);
        }
    });

    it('displays greeting', () => {
        // Create element
        const element = createElement('c-hello', {
            is: Hello
        });
        document.body.appendChild(element);

        // Verify displayed greeting
        const div = element.shadowRoot.querySelector('div');
        expect(div.textContent).toBe('Hello, World!');
    });
});


------------------------Creating an App------------------------------------
- Components
 1. Product Tile List - To display the products in a list format.
 2. Product Tile - child of 1.
 3. Paginator
 4. Placeholder