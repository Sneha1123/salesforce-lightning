// DevHub org in order to create scratch orgs
Scratch orgs has expiry of max 30 days
1 devhub can have max 25 scratch orgs
Scratch orgs are code driven
enable devhub in setup

-------------Commands---------------------

****************************create project**************************************************
//sfdx force:project:create -n "LWC tutorials"
	force is the namespace, project is topic/category of commands and under that category there 		is a command called create.

*******authorize devhub to create a scratch org and use it ***********************************
//sfdx force:auth:web:login -a lwcSneha -d
	auth is topic
	-a is alias
	-d is to make it default

***********Create Scratch Orgs**********************************
// Make changes in the scratch org config file ->
	config->project-scratch-def.json -> add attribute-> "hasSampleData":true

//sfdx force:org:create -a lwcScratchOrg1 -d 30 -f .\config\project-scratch-def.json
	-a for alias
	-d for duration
	-f for location of config file

//Set the scratch org as the default org
	ctrl+shft+P => sfdx set a default org and choose the scratch org

************************Open Scratch Org**************************************
//sfdx force:org:open

**************************Common Commands**************************************
//sfdx commands
//sfdx force:org:create --help -> to get to know the parameters needed and more info on that 				particular command

----------------------Create Lightning Component------------------------------------------------
//sfdx force:lightning:component:create -n FirstLightningComponent -d force-app\main\default\lwc

----------------------Create Apex Class---------------------------------------------------------
//sfdx force:apex:class:create -n FirstApexViaVsCode -d .\force-app\main\default\classes

-------------------------Push to scratch org----------------------------------------------------
//sfdx force:source:push

**********************************************************************************************
					RUN LWC LOCALLY
**********************************************************************************************
URL - https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.get_started_local_dev_setup

in cmd -> sfdx plugins:install @salesforce/lwc-dev-server
//sfdx plugins:update
	for updates
//sfdx force:lightning:lwc:start
	start local server

************************************************************************************************
Building First Lightning web component
************************************************************************************************
//sfdx force:lightning:component:create -n FirstExample -d .\force-app\main\default\lwc --type lwc

In order to make the component available for the lightning app builder change the <isExposed> attribute in the .xml file of the component from false to true.

In order to make the component available for record page, home page and app page --> set the targets in the xml file(aka config file)

	<targets>
        <target>lightning__RecordPage</target>
        <target>lightning__AppPage</target>
        <target>lightning__HomePage</target>
    </targets>


***************************Data Binding***********************************************************
In HTML => {property}
	eg. <template>
    <lightning-card title="Hello">
        <div class="slds-a-around-medium">
        <p class="slds-p-horizontal_small">Hello {name}</p>
    </div>
    <div class="slds-a-around-medium">

        <lightning-input label="Enter Name" value={name} onchange={changeHandler}></lightning-input>
    </div>
    </lightning-card>
</template>

In JS => importing track to make the property reactive so that whenever the property value changes, it renders the component.

	eg. 
	import { LightningElement,track } from 'lwc';

export default class DataBinding2 extends LightningElement {
    @track name = "World";
    
    changeHandler(event){
        this.name = event.target.value;
    }
}


HTML to JS -> done by Handler
JS to HTML -> done by track


*************************************************************************************************
		Rendering DOM elements Conditionally
*************************************************************************************************
- Use if:true|false directive with nested template tag
	if:true|false = {property}

**************************************************************************************************
		Rendering a list using iterator directive
***************************************************************************************************
- Either by using for:each directive or the iterative directive inside of template tag
- Iterator directive has an advantage as u can have first and last properties in that.
- Always use a key directive to assign a unique Id to each item so that if a particular item changes then the framework will use the Id to re render only the particular item changed, therefore performance optimization done.

-----------------------------FOREACH-----------------------------------------------
for:each directive use for:item = "currentItem" to access the current item

 	<ul>
           <template for:each={contacts} for:item="contact">
           <li key={contact.id}>{contact.name},{contact.title}</li>
        </template>
       </ul>


-----------------------------ITERATIVE---------------------------------------------
iterator:iteratorName={array}

-Using iteratorName we can access the below mentioned properties
	value
	index
	first - boolean value
	last - Boolean value

 <ul>
           <template iterator:it={contacts}>
               <li key={it.value.id}>
                   <div if:true={it.first} class="iterator-first"></div>
                   {it.value.name},{it.value.title}
                   <div if:true={it.last} class="iterator-last"></div>
               </li>
           </template>
       </ul>



**************************************************************************************************
				Public Properties in LWC
**************************************************************************************************
- To make properties public and reactive so that they can be used by another component -> use api decorator (@api)
- In child component(basically tht declares the public properties) -> the public properties can have default values only.
- Parent component that uses the child component in the markup can set the values.
- In order to call child component from parent component(same for attribute values of that property) 	-> use kebab case notation
- Property in .js file is mapped to the attribute in the .html file -> so in js its camel case and in html it is kebab case
- Make config changes on the parent component bcz that is what is going to be pushed to lightning app.
- Take proper care while naming.

***************************************************************************************************
			Difference between private reactive and private non reactive properties
****************************************************************************************************
- Reactive Property re-renders the component ie the changed value is vivible on the screen whereas non- reactive property doesnt ie untill the component renders the value is non visible.

****************************************************************************************************
			Boolean Properties in LWC
****************************************************************************************************
- Are public and reactive and hence uses @api decorator.
- Default value always false
- If child component used in parent then value becomes true otherwise remains false
 
****************************************************************************************************
			Component Lifecycle Hooks
****************************************************************************************************
Step 1: Constructor of Parent component is called.
Step 2: Check if any public property to be updated??
	Step 2.1: then update the public property value
Step 3: Parent Component inserted into DOM
Step 4: Connected Callback() called on Parent
Step 5: Parent rendered.
Step 6: Constructor of Child component is called.
Step 7: Check if any public property to be updated??
	Step 7.1: then update the public property value
Step 8: Child Component inserted into DOM
Step 9: Connected Callback() called on Child
Step 10: Child rendered.
Step 11: Rendered callback() called on child.
Step 12: Rendered callback() called on Parent.

--------------------------------When Component instance is removed from the DOM---------------------
Step 1: Parent Component removed from DOM
Step 2: Disconnected callback() called on Parent
Step 3: Child Component removed from DOM
Step 4: Disconnected callback() called on Child. 

****************************************************************************************************
			Component Communication through events
****************************************************************************************************
3 ways:
1. Parent to child -> Communication using methods in LWC
2. Child to Parent -> Custom event Communication in LWC
3. Two completely unrelated components -> Publish and subscriber model

------------------------------Parent to child-------------------------------------------------------
- In Aura components, child component methods could be called by the parent component by using <aura:method>
Same is done in case of LWC -> instead of aura methods they are javascript methods
@api decorator used in child methods which needs to be exposed so that it can be consumed by the parent component using javascript API.

- In parent component -> this.template.querySelector('c-todo').methodName(event.target.value);

